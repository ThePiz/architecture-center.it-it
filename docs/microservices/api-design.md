---
title: Progettazione API
description: Progettazione delle API per i microservizi
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 21cbd0d8e218e0928f137dff15c5a4762cad8dc7
ms.sourcegitcommit: fdcacbfdc77370532a4dde776c5d9b82227dff2d
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/24/2018
ms.locfileid: "49962807"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="e5353-103">Progettazione di microservizi: progettazione delle API</span><span class="sxs-lookup"><span data-stu-id="e5353-103">Designing microservices: API design</span></span>

<span data-ttu-id="e5353-104">Una buona progettazione delle API è importante in un'architettura di microservizi, perché tutto lo scambio di dati tra servizi avviene tramite messaggi o chiamate API.</span><span class="sxs-lookup"><span data-stu-id="e5353-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="e5353-105">Le API devono essere efficienti per evitare di creare [I/O frammentato](../antipatterns/chatty-io/index.md).</span><span class="sxs-lookup"><span data-stu-id="e5353-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="e5353-106">Poiché i servizi sono progettati da team che lavorano in modo indipendente, le API devono avere una semantica e schemi di controllo delle versioni ben definiti, in modo che gli aggiornamenti non interrompano altri servizi.</span><span class="sxs-lookup"><span data-stu-id="e5353-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![](./images/api-design.png)

<span data-ttu-id="e5353-107">È importante distinguere tra due tipi di API:</span><span class="sxs-lookup"><span data-stu-id="e5353-107">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="e5353-108">Le API pubbliche, chiamate dalle applicazioni client.</span><span class="sxs-lookup"><span data-stu-id="e5353-108">Public APIs that client applications call.</span></span> 
- <span data-ttu-id="e5353-109">Le API back-end, usate per la comunicazione tra i servizi.</span><span class="sxs-lookup"><span data-stu-id="e5353-109">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="e5353-110">Questi casi d'uso presentano requisiti leggermente diversi.</span><span class="sxs-lookup"><span data-stu-id="e5353-110">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="e5353-111">Un'API pubblica deve essere compatibile con le applicazioni client, in genere applicazioni browser o applicazioni native per dispositivi mobili.</span><span class="sxs-lookup"><span data-stu-id="e5353-111">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="e5353-112">Nella maggior parte dei casi, ciò vuol dire che l'API pubblica userà REST su HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5353-112">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="e5353-113">Per le API back-end è tuttavia necessario prendere in considerazione le prestazioni di rete.</span><span class="sxs-lookup"><span data-stu-id="e5353-113">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="e5353-114">A seconda della granularità dei servizi, la comunicazione tra servizi può provocare un notevole traffico di rete.</span><span class="sxs-lookup"><span data-stu-id="e5353-114">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="e5353-115">I servizi possono diventare rapidamente associati all'I/O.</span><span class="sxs-lookup"><span data-stu-id="e5353-115">Services can quickly become I/O bound.</span></span> <span data-ttu-id="e5353-116">Per questo motivo diventano più importanti considerazioni come la velocità di serializzazione e le dimensioni del payload.</span><span class="sxs-lookup"><span data-stu-id="e5353-116">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="e5353-117">Alcune alternative all'uso di REST su HTTP includono gRPC, Apache Avro e Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="e5353-117">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="e5353-118">Questi protocolli supportano la serializzazione binaria e sono in genere più efficienti di HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5353-118">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="e5353-119">Considerazioni</span><span class="sxs-lookup"><span data-stu-id="e5353-119">Considerations</span></span>

<span data-ttu-id="e5353-120">Di seguito sono illustrati alcuni aspetti da considerare quando si sceglie come implementare un'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-120">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="e5353-121">**REST rispetto a RPC**.</span><span class="sxs-lookup"><span data-stu-id="e5353-121">**REST vs RPC**.</span></span> <span data-ttu-id="e5353-122">Valutare i compromessi tra l'uso di un'interfaccia di tipo REST e di un'interfaccia di tipo RPC.</span><span class="sxs-lookup"><span data-stu-id="e5353-122">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="e5353-123">REST modella le risorse e ciò può rappresentare un modo naturale di esprimere il modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="e5353-123">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="e5353-124">Definisce un'interfaccia uniforme basata su verbi HTTP, promuovendo così la possibile evoluzione.</span><span class="sxs-lookup"><span data-stu-id="e5353-124">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="e5353-125">Presenta una semantica ben definita in termini di idempotenza, effetti collaterali e codici di risposta.</span><span class="sxs-lookup"><span data-stu-id="e5353-125">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="e5353-126">Applica una comunicazione senza stato, migliorando la scalabilità.</span><span class="sxs-lookup"><span data-stu-id="e5353-126">And it enforces stateless communication, which improves scalability.</span></span> 

- <span data-ttu-id="e5353-127">Il protocollo RPC è orientato più a operazioni o comandi.</span><span class="sxs-lookup"><span data-stu-id="e5353-127">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="e5353-128">Poiché le interfacce RPC sono simili a chiamate locali ai metodi, è possibile che vengano progettate API eccessivamente frammentate.</span><span class="sxs-lookup"><span data-stu-id="e5353-128">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="e5353-129">Questo non significa tuttavia che l'interfaccia RPC debba essere frammentata.</span><span class="sxs-lookup"><span data-stu-id="e5353-129">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="e5353-130">Significa semplicemente che è necessario prestare particolare attenzione quando si progetta l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="e5353-130">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="e5353-131">Per un'interfaccia RESTful, la scelta più comune è REST su HTTP con JSON.</span><span class="sxs-lookup"><span data-stu-id="e5353-131">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="e5353-132">Per un'interfaccia di tipo RPC esistono numerosi framework diffusi, inclusi gRPC, Apache Avro e Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="e5353-132">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache  Avro, and Apache Thrift.</span></span>

<span data-ttu-id="e5353-133">**Efficienza**.</span><span class="sxs-lookup"><span data-stu-id="e5353-133">**Efficiency**.</span></span> <span data-ttu-id="e5353-134">Prendere in considerazione l'efficienza in termini di velocità, memoria e dimensioni del payload.</span><span class="sxs-lookup"><span data-stu-id="e5353-134">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="e5353-135">In genere un'interfaccia basata su gRPC è più veloce rispetto a REST su HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5353-135">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="e5353-136">**Linguaggio di definizione dell'interfaccia**.</span><span class="sxs-lookup"><span data-stu-id="e5353-136">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="e5353-137">Il linguaggio di definizione dell'interfaccia viene usato per definire metodi e parametri e restituire i valori di un'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-137">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="e5353-138">Un linguaggio di definizione dell'interfaccia può essere usato per generare codice client, codice di serializzazione e documentazione dell'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-138">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="e5353-139">I linguaggi di definizione dell'interfaccia possono anche essere usati da strumenti di test API come Postman.</span><span class="sxs-lookup"><span data-stu-id="e5353-139">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="e5353-140">Framework come gRPC, Avro e Thrift hanno specifiche proprie per il linguaggio di definizione dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="e5353-140">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="e5353-141">REST su HTTP non ha un formato standard per il linguaggio di definizione dell'interfaccia, ma una soluzione comune è rappresentata da OpenAPI (in precedenza Swagger).</span><span class="sxs-lookup"><span data-stu-id="e5353-141">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="e5353-142">È anche possibile creare un'API REST HTTP senza usare un linguaggio di definizione formale, ma così si perderanno i vantaggi della generazione del codice e dei test.</span><span class="sxs-lookup"><span data-stu-id="e5353-142">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="e5353-143">**Serializzazione**.</span><span class="sxs-lookup"><span data-stu-id="e5353-143">**Serialization**.</span></span> <span data-ttu-id="e5353-144">Come vengono serializzati gli oggetti nella rete?</span><span class="sxs-lookup"><span data-stu-id="e5353-144">How are objects serialized over the wire?</span></span> <span data-ttu-id="e5353-145">Le opzioni includono formati basati su testo (principalmente JSON) e formati binari, ad esempio il buffer di protocollo.</span><span class="sxs-lookup"><span data-stu-id="e5353-145">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="e5353-146">I formati binari sono in genere più veloci dei formati basati su testo.</span><span class="sxs-lookup"><span data-stu-id="e5353-146">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="e5353-147">JSON presenta tuttavia vantaggi in termini di interoperabilità, perché la maggior parte dei linguaggi e dei framework supporta la serializzazione JSON.</span><span class="sxs-lookup"><span data-stu-id="e5353-147">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="e5353-148">Alcuni formati di serializzazione richiedono uno schema fisso, mentre altri richiedono la compilazione di un file di definizione dello schema.</span><span class="sxs-lookup"><span data-stu-id="e5353-148">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="e5353-149">In tal caso è necessario incorporare questo passaggio nel processo di compilazione.</span><span class="sxs-lookup"><span data-stu-id="e5353-149">In that case, you'll need to incorporate this step into your build process.</span></span> 

<span data-ttu-id="e5353-150">**Supporto di framework e linguaggi**.</span><span class="sxs-lookup"><span data-stu-id="e5353-150">**Framework and language support**.</span></span> <span data-ttu-id="e5353-151">HTTP è supportato in quasi tutti i framework e i linguaggi.</span><span class="sxs-lookup"><span data-stu-id="e5353-151">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="e5353-152">gRPC, Avro e Thrift hanno tutti librerie per C++, C#, Java e Python.</span><span class="sxs-lookup"><span data-stu-id="e5353-152">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="e5353-153">Thrift e gRPC supportano anche Go.</span><span class="sxs-lookup"><span data-stu-id="e5353-153">Thrift and gRPC also support Go.</span></span> 

<span data-ttu-id="e5353-154">**Compatibilità e interoperabilità**.</span><span class="sxs-lookup"><span data-stu-id="e5353-154">**Compatibility and interoperability**.</span></span> <span data-ttu-id="e5353-155">Se si sceglie un protocollo come gRPC, potrebbe essere necessario un livello di conversione del protocollo tra l'API pubblica e il back-end.</span><span class="sxs-lookup"><span data-stu-id="e5353-155">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="e5353-156">Questa funzione può essere svolta da un [gateway](./gateway.md).</span><span class="sxs-lookup"><span data-stu-id="e5353-156">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="e5353-157">Se si usa una rete mesh di servizi, valutare quali protocolli sono compatibili con la rete mesh di servizi.</span><span class="sxs-lookup"><span data-stu-id="e5353-157">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="e5353-158">Ad esempio, linkerd ha il supporto integrato per HTTP, Thrift e gRPC.</span><span class="sxs-lookup"><span data-stu-id="e5353-158">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span> 

<span data-ttu-id="e5353-159">In linea generale è consigliabile scegliere REST su HTTP, a meno che non siano necessari i vantaggi in termini di prestazioni offerti da un protocollo binario.</span><span class="sxs-lookup"><span data-stu-id="e5353-159">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="e5353-160">REST su HTTP non richiede librerie apposite.</span><span class="sxs-lookup"><span data-stu-id="e5353-160">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="e5353-161">Crea un accoppiamento minimo perché i chiamanti non necessitano di stub client per comunicare con il servizio.</span><span class="sxs-lookup"><span data-stu-id="e5353-161">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="e5353-162">È disponibile un ricco ecosistema di strumenti per il supporto di definizioni dello schema, test e monitoraggio degli endpoint HTTP RESTful.</span><span class="sxs-lookup"><span data-stu-id="e5353-162">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="e5353-163">HTTP è infine compatibile con i client browser, quindi non è necessario un livello di conversione del protocollo tra client e back-end.</span><span class="sxs-lookup"><span data-stu-id="e5353-163">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span> 

<span data-ttu-id="e5353-164">Se tuttavia se si sceglie REST su HTTP, è necessario eseguire test sulle prestazioni e sul carico nelle prime fasi del processo di sviluppo, per verificare che questa soluzione sia soddisfacente nello scenario.</span><span class="sxs-lookup"><span data-stu-id="e5353-164">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="e5353-165">Progettazione di API RESTful</span><span class="sxs-lookup"><span data-stu-id="e5353-165">RESTful API design</span></span>

<span data-ttu-id="e5353-166">Sono disponibili molte risorse per la progettazione delle API RESTful.</span><span class="sxs-lookup"><span data-stu-id="e5353-166">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="e5353-167">Eccone alcune che possono risultare utili:</span><span class="sxs-lookup"><span data-stu-id="e5353-167">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="e5353-168">Progettazione di API</span><span class="sxs-lookup"><span data-stu-id="e5353-168">API design</span></span>](../best-practices/api-design.md) 

- [<span data-ttu-id="e5353-169">Implementazione di API</span><span class="sxs-lookup"><span data-stu-id="e5353-169">API implementation</span></span>](../best-practices/api-implementation.md) 

- <span data-ttu-id="e5353-170">[Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines) (Linee guida per le API REST Microsoft)</span><span class="sxs-lookup"><span data-stu-id="e5353-170">[Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines)</span></span>

<span data-ttu-id="e5353-171">Occorre tenere presenti le seguenti considerazioni specifiche.</span><span class="sxs-lookup"><span data-stu-id="e5353-171">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="e5353-172">Prestare attenzione alle API che determinano una perdita di dettagli di implementazione interni o eseguono semplicemente il mirroring di uno schema di database interno.</span><span class="sxs-lookup"><span data-stu-id="e5353-172">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="e5353-173">L'API deve modellare il dominio.</span><span class="sxs-lookup"><span data-stu-id="e5353-173">The API should model the domain.</span></span> <span data-ttu-id="e5353-174">Si tratta di un contratto tra servizi e idealmente deve essere modificato solo quando viene aggiunta una nuova funzionalità, non semplicemente perché è stato eseguito il refactoring del codice oppure è stata normalizzata una tabella di database.</span><span class="sxs-lookup"><span data-stu-id="e5353-174">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span> 

- <span data-ttu-id="e5353-175">Diversi tipi di client, ad esempio applicazioni per dispositivi mobili e Web browser desktop, possono richiedere dimensioni del payload o modelli di interazione differenti.</span><span class="sxs-lookup"><span data-stu-id="e5353-175">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="e5353-176">È consigliabile usare il [modello back-end per front-end](../patterns/backends-for-frontends.md) per creare back-end separati per ogni client che espongono un'interfaccia ottimale per il client stesso.</span><span class="sxs-lookup"><span data-stu-id="e5353-176">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="e5353-177">Per le operazioni con effetti collaterali, provare a renderle idempotenti e a implementarle come metodi PUT.</span><span class="sxs-lookup"><span data-stu-id="e5353-177">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="e5353-178">Ciò consentirà di eseguire tentativi sicuri e può migliorare la resilienza.</span><span class="sxs-lookup"><span data-stu-id="e5353-178">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="e5353-179">I capitoli [Inserimento e flusso di lavoro](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) e [Comunicazione tra i servizi](./interservice-communication.md) trattano questi aspetti con maggiori dettagli.</span><span class="sxs-lookup"><span data-stu-id="e5353-179">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="e5353-180">I metodi HTTP possono avere una semantica asincrona, in cui il metodo restituisce immediatamente una risposta, mentre il servizio esegue l'operazione in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="e5353-180">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="e5353-181">In tal caso, il metodo deve restituire un codice di risposta [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), che indica che la richiesta è stata accettata per l'elaborazione, ma l'elaborazione non è stata ancora completata.</span><span class="sxs-lookup"><span data-stu-id="e5353-181">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="e5353-182">Mapping di REST a modelli di progettazione basata su dominio</span><span class="sxs-lookup"><span data-stu-id="e5353-182">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="e5353-183">I modelli come entità, aggregazione e oggetto valore sono progettati per applicare alcuni vincoli agli oggetti nel modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="e5353-183">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="e5353-184">In molte discussioni relative alla progettazione basata su dominio, i modelli vengono definiti usando concetti di linguaggio orientati a oggetti, come i costruttori o i getter e setter di proprietà.</span><span class="sxs-lookup"><span data-stu-id="e5353-184">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="e5353-185">Ad esempio, gli *oggetti valore* dovrebbero essere non modificabili.</span><span class="sxs-lookup"><span data-stu-id="e5353-185">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="e5353-186">In un linguaggio di programmazione orientato a oggetti, è necessario ottenere questo risultato assegnando valori nel costruttore e rendendo le proprietà di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="e5353-186">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="e5353-187">Queste procedure di codifica sono particolarmente importanti quando si compila un'applicazione monolitica tradizionale.</span><span class="sxs-lookup"><span data-stu-id="e5353-187">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="e5353-188">Con una base codici di grandi dimensioni, molti sottosistemi possono usare l'oggetto `Location`, quindi è importante che l'oggetto applichi il comportamento corretto.</span><span class="sxs-lookup"><span data-stu-id="e5353-188">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span> 

<span data-ttu-id="e5353-189">Un altro esempio è il modello di repository, che assicura che altre parti dell'applicazione non eseguano direttamente operazioni di lettura o scrittura nell'archivio dati:</span><span class="sxs-lookup"><span data-stu-id="e5353-189">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![](./images/repository.png)

<span data-ttu-id="e5353-190">In un'architettura di microservizi, tuttavia, i servizi non condividono la stessa base codici e non condividono archivi di dati.</span><span class="sxs-lookup"><span data-stu-id="e5353-190">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="e5353-191">Comunicano invece attraverso le API.</span><span class="sxs-lookup"><span data-stu-id="e5353-191">Instead, they communicate through APIs.</span></span> <span data-ttu-id="e5353-192">Si consideri il caso in cui il servizio Utilità di pianificazione richieda informazioni su un drone al servizio Drone.</span><span class="sxs-lookup"><span data-stu-id="e5353-192">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="e5353-193">Il servizio Drone ha un modello di drone interno espresso tramite codice,</span><span class="sxs-lookup"><span data-stu-id="e5353-193">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="e5353-194">che non è tuttavia visibile all'Utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="e5353-194">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="e5353-195">L'Utilità di pianificazione ottiene invece una *rappresentazione* dell'entità drone &mdash; eventualmente come oggetto JSON in una risposta HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5353-195">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![](./images/ddd-rest.png)

<span data-ttu-id="e5353-196">Il servizio Utilità di pianificazione non può modificare i modelli interni del servizio Drone o scrivere nell'archivio dati del servizio Drone.</span><span class="sxs-lookup"><span data-stu-id="e5353-196">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="e5353-197">Ciò significa che il codice che implementa il servizio Drone presenta una superficie esposta minore rispetto al codice di un monolito tradizionale.</span><span class="sxs-lookup"><span data-stu-id="e5353-197">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="e5353-198">Se il servizio Drone definisce una classe Location, l'ambito di tale classe è limitato &mdash; nessun altro servizio utilizzerà direttamente la classe.</span><span class="sxs-lookup"><span data-stu-id="e5353-198">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span> 

<span data-ttu-id="e5353-199">Per tali motivi, queste indicazioni non si soffermano molto sulle procedure di codifica, dato che sono correlate ai modelli di progettazione basata su dominio tattica.</span><span class="sxs-lookup"><span data-stu-id="e5353-199">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="e5353-200">È tuttavia possibile definire molti dei modelli di progettazione basata su dominio tramite le API REST.</span><span class="sxs-lookup"><span data-stu-id="e5353-200">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span> 

<span data-ttu-id="e5353-201">Ad esempio: </span><span class="sxs-lookup"><span data-stu-id="e5353-201">For example:</span></span>

- <span data-ttu-id="e5353-202">Le aggregazioni vengono mappate in modo naturale alle *risorse* in REST.</span><span class="sxs-lookup"><span data-stu-id="e5353-202">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="e5353-203">L'aggregazione relativa al recapito, ad esempio, verrà esposta come risorsa dall'API di recapito.</span><span class="sxs-lookup"><span data-stu-id="e5353-203">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="e5353-204">Le aggregazioni sono limiti di coerenza.</span><span class="sxs-lookup"><span data-stu-id="e5353-204">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="e5353-205">Le operazioni sulle aggregazioni non devono mai lasciare un'aggregazione in uno stato non coerente.</span><span class="sxs-lookup"><span data-stu-id="e5353-205">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="e5353-206">È quindi consigliabile non creare API che consentono a un client di modificare lo stato interno di un'aggregazione.</span><span class="sxs-lookup"><span data-stu-id="e5353-206">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="e5353-207">Creare invece API con granularità grossolana che espongono le aggregazioni come risorse.</span><span class="sxs-lookup"><span data-stu-id="e5353-207">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="e5353-208">Le entità hanno identità univoche.</span><span class="sxs-lookup"><span data-stu-id="e5353-208">Entities have unique identities.</span></span> <span data-ttu-id="e5353-209">In REST, le risorse hanno identificatori univoci sotto forma di URL.</span><span class="sxs-lookup"><span data-stu-id="e5353-209">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="e5353-210">Creare URL di risorsa che corrispondono all'identità di dominio di un'entità.</span><span class="sxs-lookup"><span data-stu-id="e5353-210">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="e5353-211">Il mapping dall'URL all'identità di dominio potrebbe essere opaco per il client.</span><span class="sxs-lookup"><span data-stu-id="e5353-211">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="e5353-212">Le entità figlio di un'aggregazione possono essere raggiunte passando dall'entità radice.</span><span class="sxs-lookup"><span data-stu-id="e5353-212">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="e5353-213">Se si seguono i principi [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS), le entità figlio possono essere raggiunte tramite i collegamenti disponibili nella rappresentazione dell'entità padre.</span><span class="sxs-lookup"><span data-stu-id="e5353-213">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span> 

- <span data-ttu-id="e5353-214">Poiché gli oggetti valore non sono modificabili, gli aggiornamenti vengono eseguiti sostituendo l'intero oggetto valore.</span><span class="sxs-lookup"><span data-stu-id="e5353-214">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="e5353-215">In REST, implementare gli aggiornamenti tramite richieste PUT o PATCH.</span><span class="sxs-lookup"><span data-stu-id="e5353-215">In REST, implement updates through PUT or PATCH requests.</span></span> 

- <span data-ttu-id="e5353-216">Un repository consente ai client di eseguire query e aggiungere o rimuovere gli oggetti in una raccolta, estraendo i dettagli dell'archivio dati sottostante.</span><span class="sxs-lookup"><span data-stu-id="e5353-216">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="e5353-217">In REST, una raccolta può essere una risorsa distinta, con metodi per l'esecuzione di query sulla raccolta o l'aggiunta di nuove entità alla raccolta stessa.</span><span class="sxs-lookup"><span data-stu-id="e5353-217">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="e5353-218">Quando si progettano le API, considerare il modo in cui esprimono il modello di dominio, non solo i dati all'interno del modello, ma anche le operazioni aziendali e i vincoli per i dati.</span><span class="sxs-lookup"><span data-stu-id="e5353-218">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="e5353-219">Concetto di progettazione basata su dominio</span><span class="sxs-lookup"><span data-stu-id="e5353-219">DDD concept</span></span> | <span data-ttu-id="e5353-220">Equivalente REST</span><span class="sxs-lookup"><span data-stu-id="e5353-220">REST equivalent</span></span> | <span data-ttu-id="e5353-221">Esempio</span><span class="sxs-lookup"><span data-stu-id="e5353-221">Example</span></span> | 
|-------------|-----------------|---------|
| <span data-ttu-id="e5353-222">Aggregazione</span><span class="sxs-lookup"><span data-stu-id="e5353-222">Aggregate</span></span> | <span data-ttu-id="e5353-223">Risorsa</span><span class="sxs-lookup"><span data-stu-id="e5353-223">Resource</span></span> | `{ "1":1234, "status":"pending"... }` | 
| <span data-ttu-id="e5353-224">Identità</span><span class="sxs-lookup"><span data-stu-id="e5353-224">Identity</span></span> | <span data-ttu-id="e5353-225">URL</span><span class="sxs-lookup"><span data-stu-id="e5353-225">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="e5353-226">Entità figlio</span><span class="sxs-lookup"><span data-stu-id="e5353-226">Child entities</span></span> | <span data-ttu-id="e5353-227">Collegamenti</span><span class="sxs-lookup"><span data-stu-id="e5353-227">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="e5353-228">Aggiornare oggetti valore</span><span class="sxs-lookup"><span data-stu-id="e5353-228">Update value objects</span></span> | <span data-ttu-id="e5353-229">PUT o PATCH</span><span class="sxs-lookup"><span data-stu-id="e5353-229">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="e5353-230">Repository</span><span class="sxs-lookup"><span data-stu-id="e5353-230">Repository</span></span> | <span data-ttu-id="e5353-231">Raccolta</span><span class="sxs-lookup"><span data-stu-id="e5353-231">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |


## <a name="api-versioning"></a><span data-ttu-id="e5353-232">Controllo delle versioni API</span><span class="sxs-lookup"><span data-stu-id="e5353-232">API versioning</span></span>

<span data-ttu-id="e5353-233">Un'API è un contratto tra un servizio e i client o consumer del servizio.</span><span class="sxs-lookup"><span data-stu-id="e5353-233">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="e5353-234">Con la modifica di un'API esiste il rischio di interrompere i client che dipendono dall'API, che si tratti di client esterni o altri microservizi.</span><span class="sxs-lookup"><span data-stu-id="e5353-234">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="e5353-235">È quindi consigliabile ridurre al minimo il numero di modifiche all'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-235">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="e5353-236">Spesso le modifiche apportate all'implementazione sottostante non richiedono la modifica dell'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-236">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="e5353-237">Nella realtà, tuttavia, a un certo punto si vorranno aggiungere nuove funzionalità o capacità che richiedono la modifica di un'API esistente.</span><span class="sxs-lookup"><span data-stu-id="e5353-237">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="e5353-238">Quando possibile, rendere le modifiche all'API compatibili con le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="e5353-238">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="e5353-239">Evitare ad esempio la rimozione di un campo da un modello, poiché questo può interrompere i client che necessitano di quel campo.</span><span class="sxs-lookup"><span data-stu-id="e5353-239">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="e5353-240">L'aggiunta di un campo non compromette la compatibilità, perché i client devono ignorare i campi che non riconoscono in una risposta.</span><span class="sxs-lookup"><span data-stu-id="e5353-240">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="e5353-241">Il servizio deve tuttavia gestire il caso in cui un client meno recente ometta il nuovo campo in una richiesta.</span><span class="sxs-lookup"><span data-stu-id="e5353-241">However, the service must handle the case where an older client omits the new field in a request.</span></span> 

<span data-ttu-id="e5353-242">Prevedere il supporto del controllo delle versioni nel contratto API.</span><span class="sxs-lookup"><span data-stu-id="e5353-242">Support versioning in your API contract.</span></span> <span data-ttu-id="e5353-243">Se si apporta una modifica di rilievo all'API, introdurre una nuova versione dell'API.</span><span class="sxs-lookup"><span data-stu-id="e5353-243">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="e5353-244">Mantenere il supporto della versione precedente e consentire ai client di selezionare la versione da chiamare.</span><span class="sxs-lookup"><span data-stu-id="e5353-244">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="e5353-245">Questo risultato può essere ottenuto in due modi.</span><span class="sxs-lookup"><span data-stu-id="e5353-245">There are a couple of ways to do this.</span></span> <span data-ttu-id="e5353-246">Uno prevede semplicemente l'esposizione di entrambe le versioni nello stesso servizio.</span><span class="sxs-lookup"><span data-stu-id="e5353-246">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="e5353-247">Un'altra opzione consiste nell'eseguire due versioni del servizio side-by-side e indirizzare le richieste all'una o all'altra versione, in base alle regole di routing HTTP.</span><span class="sxs-lookup"><span data-stu-id="e5353-247">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span> 

![](./images/versioning1.svg)

<span data-ttu-id="e5353-248">Il supporto di più versioni comporta un costo in termini di tempo di sviluppo, esecuzione di test e attività.</span><span class="sxs-lookup"><span data-stu-id="e5353-248">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="e5353-249">È quindi consigliabile dichiarare obsolete le versioni precedenti il prima possibile.</span><span class="sxs-lookup"><span data-stu-id="e5353-249">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="e5353-250">Per le API interne, il team a cui appartiene l'API può interagire con altri team per agevolare la migrazione alla nuova versione.</span><span class="sxs-lookup"><span data-stu-id="e5353-250">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="e5353-251">In questi casi è utile avere un processo di governance tra i team.</span><span class="sxs-lookup"><span data-stu-id="e5353-251">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="e5353-252">Per le API esterne (pubbliche), la deprecazione di una versione API può essere più complessa, soprattutto se l'API viene utilizzata da terze parti o da applicazioni client native.</span><span class="sxs-lookup"><span data-stu-id="e5353-252">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span> 

<span data-ttu-id="e5353-253">Se viene apportata una modifica all'implementazione di un servizio, è utile contrassegnare la modifica con una versione.</span><span class="sxs-lookup"><span data-stu-id="e5353-253">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="e5353-254">La versione vengono fornisce informazioni importanti in caso di risoluzione degli errori.</span><span class="sxs-lookup"><span data-stu-id="e5353-254">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="e5353-255">Ai fini dell'analisi della causa radice può essere molto utile sapere esattamente la versione del servizio chiamata.</span><span class="sxs-lookup"><span data-stu-id="e5353-255">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="e5353-256">È consigliabile usare il [versionamento semantico](https://semver.org/) per le versioni del servizio.</span><span class="sxs-lookup"><span data-stu-id="e5353-256">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="e5353-257">Il versionamento semantico usa il formato *MAJOR.MINOR.PATCH*.</span><span class="sxs-lookup"><span data-stu-id="e5353-257">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="e5353-258">I client devono tuttavia selezionare un'API solo in base al numero di versione principale o eventualmente in base al numero di versione secondario se sono presenti modifiche significative, ma non di rilievo, tra le versioni secondarie.</span><span class="sxs-lookup"><span data-stu-id="e5353-258">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="e5353-259">In altre parole, è ragionevole che i client selezionino la versione 1 o la versione 2 di un'API, ma non la versione 2.1.3.</span><span class="sxs-lookup"><span data-stu-id="e5353-259">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="e5353-260">Se si consente un tale livello di granularità, si rischia di dover supportare una proliferazione di versioni.</span><span class="sxs-lookup"><span data-stu-id="e5353-260">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span> 

<span data-ttu-id="e5353-261">Per altre considerazioni sul controllo delle versioni delle API, vedere [Controllo delle versioni di un'API Web RESTful](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="e5353-261">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="e5353-262">Inserimento e flusso di lavoro</span><span class="sxs-lookup"><span data-stu-id="e5353-262">Ingestion and workflow</span></span>](./ingestion-workflow.md)