---
title: Indicazioni generali per la ripetizione di tentativi
description: Indicazioni su come implementare un meccanismo di ripetizione dei tentativi per gestire gli errori temporanei.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 9562e3447b2219fe2f3df96cfca24b845efa39b0
ms.sourcegitcommit: c53adf50d3a787956fc4ebc951b163a10eeb5d20
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/23/2017
ms.locfileid: "25545979"
---
# <a name="transient-fault-handling"></a>Gestione degli errori temporanei

[!INCLUDE [header](../_includes/header.md)]

Tutte le applicazioni che comunicano con servizi e risorse remoti devono essere sensibili agli errori temporanei. Questa considerazione è valida soprattutto per le applicazioni in esecuzione nel cloud, in cui la natura dell'ambiente e la connettività su Internet aumentano le probabilità che si verifichino questi tipi di errore. Tra gli errori temporanei sono inclusi la perdita temporanea della connettività di rete per componenti e servizi, l'indisponibilità temporanea di un servizio o i timeout generati perché un servizio è occupato. In molti casi, questi errori si risolvono automaticamente e, se l'azione viene ripetuta dopo un intervallo di tempo appropriato, è probabile che abbia esito positivo.

Questo documento include indicazioni generali per la gestione degli errori temporanei. Per informazioni sulla gestione degli errori temporanei quando si usano i servizi di Microsoft Azure, vedere [Linee guida per la ripetizione di tentativi con i servizi di Azure](./retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>Perché si verificano errori temporanei nel cloud?
Gli errori temporanei possono verificarsi in qualsiasi ambiente, su qualsiasi piattaforma o sistema operativo e in ogni tipo di applicazione. Nelle soluzioni eseguite in un'infrastruttura locale, le prestazioni e la disponibilità dell'applicazione e dei relativi componenti vengono generalmente mantenute tramite costosi sistemi hardware con ridondanza, spesso sottoutilizzati, e i componenti e le risorse si trovano in posizioni vicine. Un'infrastruttura di questo tipo riduce le probabilità di errore, ma può comunque comportare errori temporanei e persino un'interruzione del servizio a causa di eventi imprevisti, ad esempio problemi di rete o all'alimentatore esterno o altri scenari di emergenza.

L'hosting nel cloud, anche in sistemi cloud privati, può offrire una maggiore disponibilità complessiva attraverso risorse condivise, ridondanza, failover automatico e allocazione dinamica delle risorse su un numero elevato di specifici nodi di calcolo. La natura di questi ambienti, tuttavia, può favorire la generazione di errori temporanei per vari motivi:

* In un ambiente cloud molte risorse sono condivise e l'accesso a tali risorse è soggetto a limitazione per garantirne la protezione. Alcuni servizi rifiutano le connessioni nel momento in cui il carico raggiunge un determinato livello o viene raggiunta la massima velocità effettiva, in modo da consentire l'elaborazione delle richieste esistenti e mantenere le prestazioni del servizio per tutti gli utenti. La limitazione permette quindi di mantenere la qualità del servizio per gli elementi vicini e altri tenant che usano la risorsa condivisa.
* Gli ambienti cloud vengono creati usando un elevato numero di apposite unità hardware. Garantiscono le prestazioni distribuendo il carico in modo dinamico tra più unità di elaborazione e componenti di infrastruttura e assicurano l'affidabilità riciclando o sostituendo le unità guaste in modo automatico. Questa natura dinamica fa sì che, in alcuni casi, possano verificarsi errori temporanei di connessione e altro tipo.
* Spesso sono presenti più componenti hardware, inclusi elementi dell'infrastruttura di rete come router o servizi di bilanciamento del carico, tra l'applicazione e le risorse e i servizi di cui si avvale. Questa infrastruttura aggiuntiva può talvolta introdurre ulteriore latenza di connessione ed errori di connessione temporanei.
* Le condizioni di rete tra il client e il server possono essere variabili, soprattutto quando le comunicazioni avvengono tramite Internet. Anche in percorsi locali, i carichi di traffico molto elevati possono rallentare le comunicazioni e causare errori di connessione intermittente.

## <a name="challenges"></a>Problematiche
Gli errori temporanei possono avere un forte impatto sulla disponibilità percepita di un'applicazione, anche se è stata accuratamente testata in tutte le circostanze prevedibili. Per poter funzionare in modo affidabile, le applicazioni ospitate sul cloud devono essere in grado di affrontare le difficoltà seguenti:

* L'applicazione deve essere in grado di rilevare eventuali errori nel momento in cui si verificano e determinare se si tratta di errori temporanei, di lunga durata o terminali. In caso di errore temporaneo, è probabile che risorse diverse restituiscano risposte differenti, anche a seconda del contesto dell'operazione. La risposta a un errore durante la lettura dall'unità di archiviazione, ad esempio, può essere diversa dalla risposta allo stesso errore durante la scrittura nell'unità di archiviazione. Per molti servizi e risorse sono previsti contratti di gestione degli errori temporanei ben documentati. Nel caso in cui queste informazioni non siano disponibili, tuttavia, può essere difficile individuare la natura dell'errore e stabilire se si tratta di un errore temporaneo.
* L'applicazione deve essere in grado di ripetere l'operazione se stabilisce che si tratta di un errore temporaneo e deve tenere traccia del numero di tentativi di esecuzione dell'operazione.
* L'applicazione deve adottare una strategia appropriata per la ripetizione dei tentativi, che consenta di specificare il numero di tentativi, l'intervallo di attesa tra i tentativi e le azioni da intraprendere dopo ogni tentativo non riuscito. Il numero appropriato di tentativi e l'intervallo di attesa tra di essi sono parametri spesso difficili da determinare e variano in base al tipo di risorsa e alle condizioni operative della risorsa e dell'applicazione stessa.

## <a name="general-guidelines"></a>Linee guida generali
Le linee guida seguenti consentono di definire un meccanismo di gestione degli errori temporanei adeguato alle applicazioni:

* **Determinare se esiste un meccanismo di ripetizione dei tentativi incorporato:**
  * Molti servizi forniscono una libreria client o SDK che include un meccanismo di gestione degli errori temporanei. I criteri di ripetizione usati si basano in genere sulla natura e sui requisiti del servizio di destinazione. In alternativa, le interfacce REST di alcuni servizi possono restituire informazioni utili per determinare se un nuovo tentativo è appropriato e l'intervallo di attesa prima del tentativo successivo.
  * Usare il meccanismo di ripetizione dei tentativi incorporato, se disponibile, a meno che non siano presenti requisiti specifici ed evidenti per i quali può essere più appropriato un sistema di ripetizione dei tentativi diverso.
* **Determinare se l'operazione è adatta alla ripetizione di tentativi**:
  * L'esecuzione di un'operazione dovrebbe essere ritentata solo in caso di errori temporanei (stato desumibile dalla natura dell'errore) e se c'è qualche probabilità che l'operazione abbia esito positivo con un nuovo tentativo. Sarebbe inutile, infatti, ritentare un'operazione che sussiste in un'operazione non valida, ad esempio l'aggiornamento di un database a un elemento non esistente o una richiesta inviata a un servizio o una risorsa in cui si è verificato un errore irreversibile.
  * In generale, è consigliabile ripetere i tentativi solo se è possibile determinarne l'impatto con esattezza e se le condizioni sono ben comprese e possono essere convalidate. In caso contrario, lasciare che sia il codice chiamante a ripetere i tentativi. Tenere presente che gli errori restituiti da risorse e servizi al di fuori del proprio controllo possono evolversi nel tempo e determinare la necessità di rivedere la logica di rilevamento degli errori temporanei.
  * Quando si creano servizi o componenti, prendere in considerazione l'introduzione di messaggi e codici di errore che possano aiutare i client a determinare se è opportuno ritentare operazioni non riuscite. In particolare, indicare se il client deve ritentare l'operazione (ad esempio restituendo un valore **isTransient** ) e suggerire un intervallo di tempo adeguato prima del tentativo successivo. Se si compila un servizio Web, valutare la possibilità di restituire errori personalizzati definiti all'interno dei contratti di servizio. Anche se è possibile che i client generici non siano in grado di leggerli, saranno comunque utili durante la creazione di client personalizzati.
* **Determinare un numero di tentativi e un intervallo di tempo appropriati:**
  * Questo elemento è essenziale per ottimizzare il numero di tentativi e l'intervallo di tempo in base al tipo di caso d'uso. Se non si ripete il tentativo un numero sufficiente di volte, l'applicazione non sarà in grado di completare l'operazione e potrebbe verificarsi un errore. D'altra parte, se si eseguono troppi tentativi o si definisce un intervallo eccessivo tra di essi, è possibile che l'applicazione trattenga le risorse (ad esempio thread, connessioni e memoria) per un periodo troppo lungo, influendo negativamente sull'integrità dell'applicazione.
  * I valori appropriati per l'intervallo di tempo e il numero di tentativi dipendono dal tipo di operazione che si tenta di eseguire. Ad esempio, se l'operazione fa parte di un'interazione utente, l'intervallo deve essere breve e devono essere eseguiti solo alcuni tentativi, per evitare che gli utenti restino a lungo in attesa di una risposta (intervallo durante il quale vengono mantenute connessioni aperte e la disponibilità può risultare ridotta per gli altri utenti). Se invece l'operazione fa parte di un flusso di lavoro critico o di lunga durata, in cui annullare e riavviare il processo risulterebbe molto costoso o richiederebbe molto tempo, è opportuno aumentare l'intervallo di tempo tra i tentativi e ripeterli un maggior numero di volte.
  * Determinare un intervallo di tempo appropriato tra i tentativi è l'aspetto più difficile nella definizione di una strategia corretta. Le strategie più comuni usano i seguenti tipi di intervallo tra tentativi:
    * **Backoff esponenziale**. L'applicazione attende un breve intervallo di tempo prima di ripetere il primo tentativo e aumenta in modo esponenziale il tempo di attesa prima di ogni tentativo successivo. Ad esempio, può ritentare l'operazione dopo 3 secondi, 12 secondi, 30 secondi e così via.
    * **Intervalli incrementali**. L'applicazione attende un breve intervallo di tempo prima di ripetere il primo tentativo e aumenta in modo incrementale il tempo di attesa prima di ogni tentativo successivo. Ad esempio, può ritentare l'operazione dopo 3 secondi, 7 secondi, 13 secondi e così via.
    * **Intervalli regolari**. L'applicazione attende lo stesso intervallo di tempo prima di ripetere ogni nuovo tentativo. Ad esempio, può ripetere l'operazione ogni 3 secondi.
    * **Tentativo immediato**. In alcuni casi un errore temporaneo può avere una durata molto breve, soprattutto se causato da singoli eventi come una collisione di pacchetti di rete o un picco in un componente hardware. In questo caso, è opportuno ripetere immediatamente l'operazione perché è possibile che abbia esito positivo se l'errore si è risolto nell'intervallo di tempo necessario all'applicazione per assemblare e inviare la richiesta successiva. Tuttavia, è consigliabile non ripetere più di un tentativo immediato e, in caso di esito negativo, passare piuttosto a strategie alternative, come il backoff esponenziale o azioni di fallback.
    * **Sequenza casuale**. Tutte le precedenti strategie di ripetizione dei tentativi possono includere una sequenza casuale per impedire a più istanze del client di inviare contemporaneamente nuovi tentativi. Ad esempio, un'istanza può ripetere l'operazione dopo 3 secondi, 11 secondi, 28 secondi e così via, mentre un'altra istanza può ripetere l'operazione dopo 4 secondi, 12 secondi, 26 secondi e così via. La sequenza casuale è una tecnica molto utile, soprattutto se combinata con altre strategie.  
  * Come regola generale, è consigliabile usare una strategia di backoff esponenziale per le operazioni in background e strategie di ripetizione immediata o a intervalli regolari per le operazioni interattive. In entrambi i casi è necessario scegliere l'intervallo di tempo e il numero di tentativi in modo che la latenza massima per tutti i tentativi non superi i requisiti di latenza end-to-end previsti.
  * Tenere sempre presente l'insieme dei fattori che concorrono a formare il timeout massimo complessivo per l'operazione che si tenta di eseguire. Questi fattori includono il tempo necessario a una connessione non riuscita per produrre una risposta (in genere impostato da un valore di timeout nel client), l'intervallo di tempo tra i tentativi e il numero massimo di tentativi. L'insieme di tutti i tentativi può risultare in un tempo di esecuzione complessivo molto lungo, soprattutto se si adotta una strategia di backoff esponenziale in cui l'intervallo di tempo tra i tentativi aumenta rapidamente dopo ogni errore. Se un processo deve soddisfare un contratto di servizio specifico, la durata complessiva dell'operazione, inclusi tutti i timeout e gli intervalli, deve soddisfare i requisiti definiti nel contratto di servizio.
  * Strategie di ripetizione dei tentativi eccessivamente aggressive, che prevedono intervalli troppo brevi o un numero molto elevato di tentativi, possono influire negativamente sul servizio o sulla risorsa di destinazione. Possono, ad esempio, impedire alla risorsa o al servizio di uscire dallo stato di overload, continuando a bloccare o rifiutare le richieste. Si instaura così un circolo vizioso in cui viene inviata una quantità sempre maggiore di richieste alla risorsa o al servizio, la cui capacità di recupero risulta, pertanto, ulteriormente ridotta.
  * Quando si sceglie l'intervallo tra tentativi, tenere conto del timeout delle operazioni per evitare che venga immediatamente avviato un nuovo tentativo (ad esempio, se il periodo di timeout è simile all'intervallo tra i tentativi). Valutare anche l'eventuale necessità di mantenere il periodo possibile complessivo (il timeout e l'intervallo tra tentativi) al di sotto di un determinato intervallo complessivo. Le operazioni con timeout molto lunghi o insolitamente brevi possono influire sul tempo di attesa e sulla frequenza con cui viene ripetuta l'operazione.
  * Usare il tipo di eccezione e i dati contenuti al suo interno, oppure i codici di errore e i messaggi restituiti dal servizio, per ottimizzare l'intervallo e il numero di tentativi. Alcune eccezioni o codici di errore, come il codice HTTP 503 (Service Unavailable) con intestazione Retry-After nella risposta, possono indicare, ad esempio, la durata approssimativa del servizio o che il servizio ha avuto esito negativo e non risponderà a eventuali tentativi successivi.
* **Evitare gli anti-modelli**:
  * Nella maggior parte dei casi è consigliabile evitare implementazioni che includono livelli duplicati del codice per la ripetizione dei tentativi. Evitare di progettare codice che includa meccanismi di ripetizione dei tentativi a cascata o che implementi questa logica in ogni fase di un'operazione che comporta una gerarchia di richieste, a meno che non siano previsti requisiti specifici al riguardo. In questi casi eccezionali usare criteri che impediscono un numero eccessivo di tentativi e periodi di attesa e accertarsi di comprendere le conseguenze di questo tipo di progettazione. Ad esempio, se un componente invia una richiesta a un altro, che a sua volta accede al servizio di destinazione, e si implementa una logica basata su tre tentativi per entrambe le chiamate, vi saranno in totale nove tentativi di accesso al servizio. Molti servizi e risorse implementano un meccanismo di ripetizione dei tentativi incorporato ed è opportuno determinare come disabilitare o modificare questo meccanismo se è necessario implementare la ripetizione dei tentativi a un livello superiore.
  * Non implementare mai un meccanismo a ciclo infinito. Questo può impedire alla risorsa o al servizio di uscire dallo stato di overload e di conseguenza causare la limitazione delle richieste e il rifiuto delle connessioni per un periodo di tempo più lungo. Usare un numero finito di ripetizioni dei tentativi o implementare un modello, ad esempio un [interruttore](http://msdn.microsoft.com/library/dn589784.aspx) , per consentire il ripristino del servizio.
  * Evitare di eseguire più volte una ripetizione di tentativo immediata.
  * Evitare di usare un intervallo tra tentativi regolare, soprattutto nel caso di un numero elevato di tentativi, quando si accede ai servizi e alle risorse in Azure. L'approccio ottimale per questo scenario consiste in una strategia di backoff esponenziale con una funzionalità di interruzione del circuito.
  * Evitare che più istanze dello stesso client, o più istanze di client diversi, eseguano contemporaneamente ripetizioni di tentativi. Se può verificarsi un caso di questo tipo, introdurre la tecnica di sequenza casuale negli intervalli tra tentativi.
* **Testare la strategia e l'implementazione del meccanismo di ripetizione dei tentativi:**
  * Assicurarsi di testare l'intera implementazione della strategia di ripetizione dei tentativi in un'ampia serie di condizioni possibili, soprattutto quando l'applicazione e le risorse o i servizi di destinazione usati sono sottoposti a un carico particolarmente intenso. Per controllare il comportamento durante il test, è possibile:
    * Inserire nel servizio errori temporanei e non. Ad esempio, inviare richieste non valide o aggiungere il codice che rileva le richieste di test e risponde con diversi tipi di errori. Per un esempio d'uso di TestApi, vedere [Esecuzione di test con inserimento di errori mediante TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) e il post di blog [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx) (Introduzione a TestApi – Parte 5: API gestite per l'inserimento di errori nel codice).
    * Creare una simulazione della risorsa o del servizio che restituisce un intervallo di errori possibili in un contesto reale. Assicurarsi di coprire tutti i tipi di errore che la strategia di ripetizione dei tentativi prevede di rilevare.
    * Forzare la generazione di errori temporanei tramite la disabilitazione o l'overload del servizio, se si tratta di un servizio personalizzato creato e distribuito personalmente (ovviamente non provare a eseguire l'overload di risorse o servizi condivisi all'interno di Azure).
    * Per le API basate su HTTP, valutare l'opportunità di usare la libreria FiddlerCore nei test automatizzati per cambiare l'esito delle richieste HTTP aggiungendo tempi di round trip o cambiando la risposta (ad esempio, il codice di stato HTTP, le intestazioni, il corpo o altri fattori). Questo consente il test deterministico di un sottoinsieme delle condizioni di errore, per errori sia temporanei che di altro tipo. Per altre informazioni, vedere [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Per esempi di come usare la libreria, in particolare la classe **HttpMangler** , esaminare il [codice sorgente per Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).
    * Eseguire test simultanei e a fattore di carico elevato per assicurarsi che il meccanismo e la strategia di ripetizione dei tentativi funzionino correttamente in queste condizioni e non abbiano effetti negativi sul funzionamento del client né causino la contaminazione incrociata tra le richieste.
* **Gestire le configurazioni dei criteri di ripetizione dei tentativi:**
  * Un *criterio di ripetizione dei tentativi* è il risultato della combinazione di tutti gli elementi della strategia di ripetizione dei tentativi. Questo criterio definisce il meccanismo di rilevamento che determina se un errore è presumibilmente temporaneo, il tipo di intervallo da usare (ad esempio, normale, esponenziale, di backoff e a sequenza casuale), uno o più valori di intervallo effettivi e il numero di volte in cui vengono ripetuti i tentativi.
  * Il meccanismo di ripetizione dei tentativi deve essere implementato in molti punti all'interno della più semplice applicazione e in ogni livello delle applicazioni più complesse. Anziché impostare come hardcoded gli elementi di ogni criterio in più punti del codice, può essere opportuno usare un punto centrale per l'archiviazione di tutti i criteri. Ad esempio, archiviare valori come l'intervallo e il numero di tentativi nei file di configurazione dell'applicazione, leggerli in fase di esecuzione e compilare a livello di codice i criteri di ripetizione dei tentativi. In questo modo è più semplice gestire le impostazioni e ottimizzare i valori in modo da soddisfare scenari e requisiti variabili. È tuttavia opportuno progettare il sistema in modo da archiviare i valori anziché rileggere ogni volta un file di configurazione e verificare che vengano usati i valori predefiniti idonei, se non possono essere ottenuti dalla configurazione.
  * In un'applicazione di servizi cloud di Azure è consigliabile archiviare nel file di configurazione del servizio i valori usati per creare i criteri di ripetizione dei tentativi in fase di esecuzione, in modo che possano essere modificati senza il riavvio dell'applicazione.
  * Sfruttare le strategie di ripetizione dei tentativi incorporate o predefinite disponibili nelle API client in uso, ma solo se sono adatte allo scenario. Queste strategie sono normalmente progettate per finalità generiche. In alcuni scenari possono soddisfare tutti i requisiti, mentre in altri possono non offrire l'intera gamma di opzioni necessaria per soddisfare requisiti specifici. È necessario comprendere come le impostazioni avranno effetto sull'applicazione eseguendo test per determinare i valori più appropriati.
* **Tenere traccia degli errori temporanei e non:**
  * Come parte della strategia di ripetizione dei tentativi, includere la gestione delle eccezioni e altra strumentazione in grado di registrare i tentativi effettuati. Se un errore temporaneo e una ripetizione di tentativo occasionale sono possibili e non rivelano la presenza di problemi, un numero di tentativi in costante crescita è spesso indicativo di un problema che può generare un errore o che influisce sulle prestazioni e sulla disponibilità dell'applicazione.
  * Registrare gli errori temporanei come voci di avviso anziché di errore per evitare che i sistemi di monitoraggio non rilevino tali voci come errori dell'applicazione generando falsi allarmi.
  * Può essere opportuno archiviare nelle voci di log un valore che indica se la ripetizione dei tentativi è stata causata dalla limitazione del servizio o da altri tipi di errore, ad esempio errori di connessione, in modo da poterli differenziare durante l'analisi dei dati. Un aumento del numero di errori di limitazione è spesso indicativo di un problema di progettazione nell'applicazione o della necessità di passare a un servizio premium in grado di offrire hardware dedicato.  
  * Può essere utile misurare e registrare il tempo totale impiegato per le operazioni che includono un meccanismo di ripetizione dei tentativi. Questo tempo è un buon indicatore dell'impatto complessivo degli errori temporanei sui tempi di risposta degli utenti, sulla latenza dei processi e sull'efficienza dei casi d'uso delle applicazioni. Registrare anche il numero di tentativi che si sono verificati per comprendere i fattori che hanno influito sul tempo di risposta.
  * Prendere in considerazione l'opportunità di implementare un sistema di telemetria e monitoraggio in grado di generare avvisi quando il numero e la frequenza di errori, il numero medio di tentativi o il tempo complessivo per il completamento delle operazioni risulta in aumento.
* **Gestire le operazioni che continuano ad avere esito negativo:**
  
  * In alcune circostanze l'operazione continua ad avere esito negativo a ogni tentativo ed è molto importante determinare la modalità di gestione appropriata per questa situazione:
    * Anche se una strategia di ripetizione dei tentativi definisce il numero massimo di volte in cui deve essere ripetuto il tentativo di esecuzione di un'operazione, tale strategia non impedisce un'ulteriore ripetizione dell'operazione, con lo stesso numero di tentativi. Ad esempio, se un servizio di elaborazione degli ordini ha esito negativo con un errore irreversibile che lo rende inutilizzabile in modo permanente, la strategia di ripetizione dei tentativi potrebbe rilevare un timeout della connessione e valutare che si tratta di un errore temporaneo. Il codice ripeterà l'operazione il numero di volte specificato e quindi rinuncerà a completarla. Tuttavia, quando un altro cliente eseguirà un ordine, l'operazione verrà ritentata, anche se è sicuro che l'esito sarà sempre negativo.
    * Per evitare tentativi continui per operazioni che hanno sempre esito negativo, può essere opportuno implementare il [modello di interruttore](http://msdn.microsoft.com/library/dn589784.aspx). In questo modello, se il numero di errori entro un intervallo di tempo specificato supera la soglia, le richieste vengono restituite immediatamente al chiamante come errori, senza provare ad accedere alla risorsa o al servizio non riuscito.
    * L'applicazione può testare periodicamente il servizio, in modo intermittente e a intervalli di tempo molto lunghi tra le richieste, per rilevare quando diventa disponibile. La durata appropriata dell'intervallo di tempo dipende dallo scenario, ad esempio l'importanza dell'operazione e la natura del servizio, e può variare da pochi minuti a diverse ore. Nel momento in cui il test ha esito positivo, l'applicazione può riprendere le normali operazioni e passare richieste al servizio appena ripristinato.
    * Nel frattempo può essere possibile eseguire il fallback a un'altra istanza del servizio (ad esempio in un'applicazione o un data center diverso), usare un servizio simile in grado di offrire funzionalità compatibili (magari più semplici) o eseguire operazioni alternative nella speranza che il servizio diventi presto disponibile. Ad esempio, può essere opportuno archiviare le richieste relative al servizio in una coda o un archivio dati e riprodurle in un secondo momento. In alternativa, è possibile reindirizzare l'utente a un'altra istanza dell'applicazione, ridurre le prestazioni dell'applicazione offrendo comunque una funzionalità accettabile o semplicemente restituire un messaggio all'utente per segnalare che l'applicazione non è al momento disponibile.
* **Altre considerazioni**
  
  * Quando si scelgono i valori relativi al numero di ripetizioni dei tentativi e agli intervalli tra tentativi per  criteri, è necessario valutare se l'operazione eseguita sul servizio o sulla risorsa fa parte di un'operazione di lunga durata o articolata in più fasi. Può essere difficile o dispendioso controbilanciare tutte le altre fasi operative che hanno già avuto esito positivo quando una fase non viene completata. In questo caso, un intervallo molto lungo e un numero elevato di tentativi può essere accettabile, purché non impedisca l'esecuzione di altre operazioni bloccando le risorse.
  * Valutare se la ripetizione della stessa operazione può causare incoerenze nei dati. Se alcune parti di un processo in più fasi vengono ripetute e le operazioni non sono idempotenti, può verificarsi un'incoerenza. Ad esempio, se un'operazione incrementa un valore e viene ripetuta, genererà un risultato non valido. La ripetizione di un'operazione che invia un messaggio a una coda può causare un'incoerenza nel consumer di messaggi se non riesce a rilevare i messaggi duplicati. Per evitare questo problema, assicurarsi di progettare ogni fase come un'operazione idempotente. Per altre informazioni sull'idempotenza, vedere [Idempotency Patterns][idempotency-patterns] (Modelli di idempotenza).
  * Valutare l'ambito delle operazioni per cui verrà ripetuto il tentativo di esecuzione. Ad esempio, potrebbe essere più facile implementare il codice di ripetizione dei tentativi a un livello che include più operazioni e quindi ripeterle tutte se qualcuna ha esito negativo. Tuttavia, questa operazione può causare problemi di idempotenza o operazioni di rollback non necessarie.
  * Se si sceglie un ambito che comprende più operazioni, è opportuno prendere in considerazione la latenza totale di tutte le operazioni nel determinare gli intervalli tra tentativi, nel monitorare il tempo impiegato e prima di generare avvisi per gli errori.
  * Valutare come le strategia di ripetizione dei tentativi può influire sui vicini e su altri tenant in un'applicazione condivisa o quando si usano risorse e servizi condivisi. L'adozione di criteri aggressivi di ripetizione dei tentativi possono causare un numero crescente di errori temporanei si verifichi per gli altri utenti e per le applicazioni che condividono le risorse e i servizi. Analogamente, l'applicazione può essere influenzata dai criteri di ripetizione dei tentativi implementati da altri utenti dei servizi e delle risorse. Per le applicazioni mission-critical, è possibile decidere di usare servizi premium non condivisi. Ciò consente un maggiore controllo sul carico e la conseguente limitazione delle richieste di tali risorse e servizi, giustificando così il costo aggiuntivo.

## <a name="more-information"></a>Altre informazioni
* [Linee guida per la ripetizione di tentativi con i servizi di Azure](./retry-service-specific.md)
* [Blocco di applicazioni per la gestione degli errori temporanei](http://msdn.microsoft.com/library/hh680934.aspx)
* [Modello di interruttore](http://msdn.microsoft.com/library/dn589784.aspx)
* [Modello di transazioni di compensazione](http://msdn.microsoft.com/library/dn589804.aspx)
* [Idempotency Patterns][idempotency-patterns] (Modelli di idempotenza)

[idempotency-patterns]: http://blog.jonathanoliver.com/idempotency-patterns/

