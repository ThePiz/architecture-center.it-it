---
title: Modello di tabella degli indici
titleSuffix: Cloud Design Patterns
description: Creare indici sui campi negli archivi dati spesso referenziati dalle query.
keywords: schema progettuale
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: e3373a50ba6298f7985182b7be244db5f6eaa703
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 03/20/2019
ms.locfileid: "58249296"
---
# <a name="index-table-pattern"></a><span data-ttu-id="1e292-104">Modello di tabella degli indici</span><span class="sxs-lookup"><span data-stu-id="1e292-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="1e292-105">Creare indici sui campi negli archivi dati spesso referenziati dalle query.</span><span class="sxs-lookup"><span data-stu-id="1e292-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="1e292-106">Questo modello può migliorare le prestazioni delle query, consentendo alle applicazioni di individuare più rapidamente i dati da recuperare da un archivio dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="1e292-107">Contesto e problema</span><span class="sxs-lookup"><span data-stu-id="1e292-107">Context and problem</span></span>

<span data-ttu-id="1e292-108">Molti archivi dati consentono di organizzare i dati per una raccolta di entità usando la chiave primaria.</span><span class="sxs-lookup"><span data-stu-id="1e292-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="1e292-109">Un'applicazione può usare questa chiave per individuare e recuperare i dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="1e292-110">Nella figura viene illustrato un esempio di un archivio dati che contiene informazioni sul cliente.</span><span class="sxs-lookup"><span data-stu-id="1e292-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="1e292-111">La chiave primaria è l'ID cliente.</span><span class="sxs-lookup"><span data-stu-id="1e292-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="1e292-112">La figura mostra informazioni sul cliente organizzate per la chiave primaria (ID cliente).</span><span class="sxs-lookup"><span data-stu-id="1e292-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![Figura 1. Informazioni sul cliente organizzate per la chiave primaria (ID cliente)](./_images/index-table-figure-1.png)

<span data-ttu-id="1e292-114">Mentre la chiave primaria è utile per le query che recuperano i dati in base al suo valore, un'applicazione potrebbe non riuscire a usare la chiave primaria se è necessario recuperare i dati in base a un altro campo.</span><span class="sxs-lookup"><span data-stu-id="1e292-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="1e292-115">Nell'esempio dei clienti un'applicazione non può usare la chiave primaria ID cliente per recuperare i clienti se sottopone a query i dati facendo riferimento solamente al valore di qualche altro attributo, ad esempio la città in cui si trova il cliente.</span><span class="sxs-lookup"><span data-stu-id="1e292-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="1e292-116">Per eseguire una query come questa, l'applicazione potrebbe dover recuperare ed esaminare ogni record del cliente, processo che potrebbe rivelarsi lento.</span><span class="sxs-lookup"><span data-stu-id="1e292-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="1e292-117">Molti sistemi di gestione di database relazionali supportano gli indici secondari.</span><span class="sxs-lookup"><span data-stu-id="1e292-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="1e292-118">Un indice secondario è una struttura dei dati separata organizzata per uno o più campi chiave non primari (secondari) e indica dove sono archiviati i dati per ogni valore indicizzato.</span><span class="sxs-lookup"><span data-stu-id="1e292-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="1e292-119">In genere, gli elementi in un indice secondario sono ordinati in base al valore delle chiavi secondarie per consentire una ricerca rapida dei dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="1e292-120">Questi indici sono in genere gestiti automaticamente dal sistema di gestione di database.</span><span class="sxs-lookup"><span data-stu-id="1e292-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="1e292-121">È possibile creare tutti gli indici secondari necessari per supportare le diverse query eseguite dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1e292-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="1e292-122">Ad esempio, in una tabella Clienti in un database relazionale dove l'ID cliente è la chiave primaria, è utile aggiungere un indice secondario sul campo della città se l'applicazione cerca spesso i clienti per la città in cui risiedono.</span><span class="sxs-lookup"><span data-stu-id="1e292-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="1e292-123">Tuttavia, anche se gli indici secondari sono comuni nei sistemi relazionali, la maggior parte degli archivi dati NoSQL usati dalle applicazioni cloud non fornisce una funzionalità equivalente.</span><span class="sxs-lookup"><span data-stu-id="1e292-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="1e292-124">Soluzione</span><span class="sxs-lookup"><span data-stu-id="1e292-124">Solution</span></span>

<span data-ttu-id="1e292-125">Se l'archivio dati non supporta gli indici secondari, è possibile emularli manualmente tramite la creazione di tabelle dell'indice.</span><span class="sxs-lookup"><span data-stu-id="1e292-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="1e292-126">Una tabella dell'indice consente di organizzare i dati in base a una chiave specifica.</span><span class="sxs-lookup"><span data-stu-id="1e292-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="1e292-127">Per strutturare una tabella dell'indice, vengono comunemente usate tre strategie, a seconda del numero di indici secondari necessari e della natura delle query eseguite da un'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1e292-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="1e292-128">La prima strategia consiste nel duplicare i dati in ciascuna tabella dell'indice organizzandoli però in base a chiavi diverse (denormalizzazione completa).</span><span class="sxs-lookup"><span data-stu-id="1e292-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="1e292-129">La figura seguente mostra le tabelle dell'indice che consentono di organizzare le informazioni del cliente in base a Town (Città) e LastName (Cognome).</span><span class="sxs-lookup"><span data-stu-id="1e292-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![Figura 2. I dati vengono duplicati in ciascuna tabella dell'indice](./_images/index-table-figure-2.png)

<span data-ttu-id="1e292-131">Questa strategia è adeguata se i dati sono relativamente statici rispetto al numero di volte in cui vengono sottoposti a query usando ciascuna chiave.</span><span class="sxs-lookup"><span data-stu-id="1e292-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="1e292-132">Se i dati sono più dinamici, il sovraccarico della gestione di ogni tabella dell'indice diventa troppo grande perché questo approccio sia utile.</span><span class="sxs-lookup"><span data-stu-id="1e292-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="1e292-133">Inoltre, se il volume dei dati è molto elevato, la quantità di spazio necessaria per archiviare i dati duplicati diventa significativa.</span><span class="sxs-lookup"><span data-stu-id="1e292-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="1e292-134">La seconda strategia consiste nel creare le tabelle dell'indice normalizzate organizzate in base a diverse chiavi e nel far riferimento ai dati originali usando la chiave primaria, anziché duplicandola, come illustrato nella figura seguente.</span><span class="sxs-lookup"><span data-stu-id="1e292-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="1e292-135">I dati originali vengono chiamati da una tabella dei fatti.</span><span class="sxs-lookup"><span data-stu-id="1e292-135">The original data is called a fact table.</span></span>

![Figura 3. Dati a cui si fa riferimento da ogni tabella dell'indice](./_images/index-table-figure-3.png)

<span data-ttu-id="1e292-137">Questa tecnica consente di risparmiare spazio e riduce il sovraccarico della gestione dei dati duplicati.</span><span class="sxs-lookup"><span data-stu-id="1e292-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="1e292-138">Lo svantaggio è che un'applicazione deve eseguire due operazioni di ricerca per trovare i dati usando una chiave secondaria.</span><span class="sxs-lookup"><span data-stu-id="1e292-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="1e292-139">Deve trovare la chiave primaria per i dati nella tabella dell'indice e quindi usare la chiave primaria per cercare i dati nella tabella dei fatti.</span><span class="sxs-lookup"><span data-stu-id="1e292-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="1e292-140">La terza strategia consiste nel creare tabelle dell'indice parzialmente normalizzate organizzate in base a chiavi diverse che duplicano spesso i campi recuperati.</span><span class="sxs-lookup"><span data-stu-id="1e292-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="1e292-141">Fare riferimento alla tabella dei fatti per accedere ai campi con accesso meno frequente.</span><span class="sxs-lookup"><span data-stu-id="1e292-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="1e292-142">La figura successiva illustra come i campi usati più frequentemente vengano duplicati in ogni tabella dell'indice.</span><span class="sxs-lookup"><span data-stu-id="1e292-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![Figura 4. I campi usati più frequentemente vengono duplicati in ogni tabella dell'indice](./_images/index-table-figure-4.png)

<span data-ttu-id="1e292-144">Con questa strategia, è possibile raggiungere un equilibrio tra i primi due approcci.</span><span class="sxs-lookup"><span data-stu-id="1e292-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="1e292-145">I dati per le query comuni possono essere recuperati rapidamente usando una singola ricerca, mentre il sovraccarico dello spazio e della manutenzione non è significativo come duplicare l'intero set di dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="1e292-146">Se un'applicazione esegue di frequente query di dati specificando una combinazione di valori (ad esempio, "Trova tutti i clienti che risiedono a Redmond e di cognome Smith"), è possibile implementare le chiavi negli elementi della tabella dell'indice come una concatenazione degli attributi Town (Città) e LastName (Cognome).</span><span class="sxs-lookup"><span data-stu-id="1e292-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="1e292-147">La figura seguente mostra una tabella dell'indice basata sulle chiavi composte.</span><span class="sxs-lookup"><span data-stu-id="1e292-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="1e292-148">Le chiavi vengono ordinate in base a Town (Città) e quindi a LastName (Cognome) per i record che hanno lo stesso valore per Town (Città).</span><span class="sxs-lookup"><span data-stu-id="1e292-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![Figura 5. Una tabella dell'indice basata sulle chiavi composte](./_images/index-table-figure-5.png)

<span data-ttu-id="1e292-150">Le tabelle dell'indice possono velocizzare le operazioni di query su dati partizionati e sono particolarmente utili laddove la chiave di partizione venga sottoposta a hash.</span><span class="sxs-lookup"><span data-stu-id="1e292-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="1e292-151">La figura seguente mostra un esempio in cui la chiave di partizione è un hash dell'ID cliente.</span><span class="sxs-lookup"><span data-stu-id="1e292-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="1e292-152">La tabella dell'indice può organizzare i dati in base al valore senza hash (Town [Città] e LastName [Cognome]) e fornire la chiave di partizione con hash come i dati di ricerca.</span><span class="sxs-lookup"><span data-stu-id="1e292-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="1e292-153">Ciò consente di evitare all'applicazione di calcolare ripetutamente le chiavi hash (operazione dispendiosa) quando occorre recuperare i dati che rientrano in un intervallo o recuperare i dati nell'ordine della chiave senza hash.</span><span class="sxs-lookup"><span data-stu-id="1e292-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="1e292-154">Ad esempio, una query come "Trova tutti i clienti che risiedono in Redmond" può essere risolta rapidamente individuando gli elementi corrispondenti nella tabella dell'indice, in cui sono tutti archiviati in un blocco contiguo.</span><span class="sxs-lookup"><span data-stu-id="1e292-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="1e292-155">Seguire quindi i riferimenti ai dati dei clienti usando le chiavi di partizione archiviate nella tabella dell'indice.</span><span class="sxs-lookup"><span data-stu-id="1e292-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![Figura 6. Una tabella dell'indice che fornisce una ricerca rapida dei dati partizionati](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="1e292-157">Considerazioni e problemi</span><span class="sxs-lookup"><span data-stu-id="1e292-157">Issues and considerations</span></span>

<span data-ttu-id="1e292-158">Prima di decidere come implementare questo modello, considerare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="1e292-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="1e292-159">Il sovraccarico della gestione degli indici secondari può essere significativo.</span><span class="sxs-lookup"><span data-stu-id="1e292-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="1e292-160">È necessario analizzare e comprendere le query usate dall'applicazione.</span><span class="sxs-lookup"><span data-stu-id="1e292-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="1e292-161">Creare le tabelle dell'indice solo quando possono essere usate regolarmente.</span><span class="sxs-lookup"><span data-stu-id="1e292-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="1e292-162">Non creare tabelle dell'indice speculative per supportare le query che un'applicazione non esegue o esegue solo occasionalmente.</span><span class="sxs-lookup"><span data-stu-id="1e292-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="1e292-163">La duplicazione dei dati in una tabella dell'indice può aggiungere un sovraccarico significativo ai costi di archiviazione e allo sforzo necessario per mantenere più copie di dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="1e292-164">L'implementazione di una tabella dell'indice come una struttura normalizzata che fa riferimento ai dati originali richiede che un'applicazione esegua due operazioni di ricerca per trovare i dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="1e292-165">La prima operazione fa una ricerca nella tabella dell'indice per recuperare la chiave primaria, mentre la seconda usa la chiave primaria per recuperare i dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="1e292-166">Se un sistema incorpora un numero di tabelle dell'indice su set di dati molto grandi, può rendere difficile mantenere la coerenza tra le tabelle dell'indice e i dati originali.</span><span class="sxs-lookup"><span data-stu-id="1e292-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="1e292-167">Potrebbe essere possibile progettare l'applicazione sulla base del modello di coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="1e292-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="1e292-168">Ad esempio, per inserire, aggiornare o eliminare dati, un'applicazione può inviare un messaggio a una coda e consentire a un'attività separata di eseguire l'operazione e mantenere le tabelle dell'indice che fanno riferimento a questi dati in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="1e292-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="1e292-169">Per altre informazioni sull'implementazione della coerenza finale, vedere [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) (Informazioni relative alla coerenza dei dati).</span><span class="sxs-lookup"><span data-stu-id="1e292-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="1e292-170">Le tabelle di archiviazione di Microsoft Azure supportano gli aggiornamenti transazionali per le modifiche apportate ai dati contenuti nella stessa partizione (definite come transazioni dei gruppi di entità).</span><span class="sxs-lookup"><span data-stu-id="1e292-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="1e292-171">Se è possibile archiviare i dati di una tabella dei fatti e di una o più tabelle dell'indice nella stessa partizione, questa funzionalità può essere usata per garantire la coerenza.</span><span class="sxs-lookup"><span data-stu-id="1e292-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="1e292-172">Le stesse tabelle dell'indice potrebbero essere partizionate.</span><span class="sxs-lookup"><span data-stu-id="1e292-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="1e292-173">Quando usare questo modello</span><span class="sxs-lookup"><span data-stu-id="1e292-173">When to use this pattern</span></span>

<span data-ttu-id="1e292-174">Usare questo modello per migliorare le prestazioni delle query quando un'applicazione deve poter recuperare spesso i dati con una chiave diversa dalla chiave primaria (o di partizione).</span><span class="sxs-lookup"><span data-stu-id="1e292-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="1e292-175">Questo modello potrebbe non essere utile quando:</span><span class="sxs-lookup"><span data-stu-id="1e292-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="1e292-176">I dati sono volatili.</span><span class="sxs-lookup"><span data-stu-id="1e292-176">Data is volatile.</span></span> <span data-ttu-id="1e292-177">Una tabella dell'indice può diventare obsoleta molto rapidamente, diventando inefficace o rendendo il sovraccarico della gestione della tabella dell'indice superiore a qualsiasi risparmio ottenuto usandola.</span><span class="sxs-lookup"><span data-stu-id="1e292-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="1e292-178">Un campo selezionato come chiave secondaria di una tabella dell'indice non è discriminante e può avere solo un piccolo set di valori (ad esempio il genere).</span><span class="sxs-lookup"><span data-stu-id="1e292-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="1e292-179">L'equilibrio dei valori dei dati di un campo selezionato come chiave secondaria per una tabella dell'indice viene fortemente alterato.</span><span class="sxs-lookup"><span data-stu-id="1e292-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="1e292-180">Se ad esempio il 90% dei record contiene lo stesso valore in un campo, creare e gestire una tabella dell'indice per cercare i dati in base a questo campo potrebbe generare un sovraccarico superiore rispetto all'analisi sequenziale dei dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="1e292-181">Tuttavia questo indice può rivelarsi utile qualora le query facciano molto spesso riferimento ai valori presenti nel restante 10%.</span><span class="sxs-lookup"><span data-stu-id="1e292-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="1e292-182">È necessario comprendere le query eseguite dall'applicazione e la frequenza di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="1e292-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="1e292-183">Esempio</span><span class="sxs-lookup"><span data-stu-id="1e292-183">Example</span></span>

<span data-ttu-id="1e292-184">Le tabelle di archiviazione di Azure offrono un archivio di dati chiave/valore altamente scalabile per le applicazioni in esecuzione nel cloud.</span><span class="sxs-lookup"><span data-stu-id="1e292-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="1e292-185">Le applicazioni archiviano e recupero i valori dei dati specificando una chiave.</span><span class="sxs-lookup"><span data-stu-id="1e292-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="1e292-186">I valori dei dati possono contenere più campi, ma la struttura di un elemento di dati è opaca per l'archiviazione tabelle, che gestisce semplicemente un elemento di dati come una matrice di byte.</span><span class="sxs-lookup"><span data-stu-id="1e292-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="1e292-187">Le tabelle di archiviazione di Azure supportano anche il partizionamento orizzontale.</span><span class="sxs-lookup"><span data-stu-id="1e292-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="1e292-188">La chiave di partizionamento orizzontale include due elementi: una chiave di partizione e una chiave di riga.</span><span class="sxs-lookup"><span data-stu-id="1e292-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="1e292-189">Gli elementi che hanno la stessa chiave di partizione vengono archiviati nella stessa partizione, mentre gli elementi vengono archiviati in base alla chiave di riga all'interno di una partizione.</span><span class="sxs-lookup"><span data-stu-id="1e292-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="1e292-190">L'archiviazione tabelle viene ottimizzata per eseguire le query che recuperano i dati appartenenti a un intervallo contiguo di valori di chiave di riga all'interno di una partizione.</span><span class="sxs-lookup"><span data-stu-id="1e292-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="1e292-191">Se si stanno creando applicazioni cloud che archiviano informazioni nelle tabelle di Azure, è necessario strutturare i dati tenendo presente questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="1e292-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="1e292-192">Ad esempio, si consideri un'applicazione che archivia le informazioni sui film.</span><span class="sxs-lookup"><span data-stu-id="1e292-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="1e292-193">L'applicazione sottopone spesso a query i film per genere (azione, documentari, storici, commedie, drammatici, e così via).</span><span class="sxs-lookup"><span data-stu-id="1e292-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="1e292-194">È possibile creare una tabella di Azure con partizioni per ogni genere usando il genere come chiave di partizione e indicando il nome del film come chiave di riga, come illustrato nella figura riportata di seguito.</span><span class="sxs-lookup"><span data-stu-id="1e292-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![Figura 7. Dati dei film archiviati in una tabella di Azure](./_images/index-table-figure-7.png)

<span data-ttu-id="1e292-196">Questo approccio è meno efficace se l'applicazione deve anche sottoporre a query i film in base all'attore.</span><span class="sxs-lookup"><span data-stu-id="1e292-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="1e292-197">In questo caso, è possibile creare una tabella di Azure separata che agisce come una tabella dell'indice.</span><span class="sxs-lookup"><span data-stu-id="1e292-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="1e292-198">La chiave di partizione è l'attore mentre la chiave di riga è il nome del film.</span><span class="sxs-lookup"><span data-stu-id="1e292-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="1e292-199">I dati di ogni attore sono archiviati in partizioni distinte.</span><span class="sxs-lookup"><span data-stu-id="1e292-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="1e292-200">Se un film è interpretato da più attori, lo stesso film si presenterà in più partizioni.</span><span class="sxs-lookup"><span data-stu-id="1e292-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="1e292-201">È possibile duplicare i dati dei film nei valori mantenuti per ogni partizione adottando il primo approccio descritto nella precedente sezione Soluzione.</span><span class="sxs-lookup"><span data-stu-id="1e292-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="1e292-202">Tuttavia è probabile che ogni film verrà replicato più volte (una volta per ogni attore), pertanto potrebbe essere più efficiente denormalizzare parzialmente i dati per supportare le query più comuni (ad esempio i nomi degli altri attori) e consentire a un'applicazione di recuperare le informazioni rimanenti includendo la chiave di partizione necessaria per trovare le informazioni complete nelle partizioni del genere.</span><span class="sxs-lookup"><span data-stu-id="1e292-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="1e292-203">Questo approccio è descritto dalla terza opzione nella sezione Soluzione.</span><span class="sxs-lookup"><span data-stu-id="1e292-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="1e292-204">La figura seguente illustra questo approccio.</span><span class="sxs-lookup"><span data-stu-id="1e292-204">The next figure shows this approach.</span></span>

![Figura 8. Partizioni attore che fungono da tabelle dell'indice per i dati del film](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="1e292-206">Modelli correlati e informazioni aggiuntive</span><span class="sxs-lookup"><span data-stu-id="1e292-206">Related patterns and guidance</span></span>

<span data-ttu-id="1e292-207">Per l'implementazione di questo modello possono risultare utili i modelli e le informazioni aggiuntive seguenti:</span><span class="sxs-lookup"><span data-stu-id="1e292-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="1e292-208">[Nozioni di base sulla coerenza dei dati](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="1e292-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="1e292-209">Una tabella dell'indice deve essere gestita come i dati di cui indicizza le modifiche.</span><span class="sxs-lookup"><span data-stu-id="1e292-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="1e292-210">Nel cloud, potrebbe non essere possibile o necessario eseguire le operazioni di aggiornamento di un indice come parte della stessa transazione che modifica i dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="1e292-211">In tal caso, è più indicato un approccio per la coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="1e292-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="1e292-212">Vengono fornite informazioni sui problemi legati alla coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="1e292-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="1e292-213">[Modello di partizionamento orizzontale](./sharding.md).</span><span class="sxs-lookup"><span data-stu-id="1e292-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="1e292-214">Il modello di tabella dell'indice viene spesso usato in combinazione con dati partizionati tramite le partizioni.</span><span class="sxs-lookup"><span data-stu-id="1e292-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="1e292-215">Il modello di partizionamento orizzontale offre altre informazioni su come suddividere un archivio dati in un set di partizioni.</span><span class="sxs-lookup"><span data-stu-id="1e292-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="1e292-216">[Modello di vista materializzata](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="1e292-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="1e292-217">Anziché indicizzare i dati per supportare le query che riepilogano i dati, potrebbe essere più appropriato creare una vista materializzata dei dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="1e292-218">Descrive come supportare query riepilogative efficienti generando viste prepopolate sui dati.</span><span class="sxs-lookup"><span data-stu-id="1e292-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
